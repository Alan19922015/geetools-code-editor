/***
 * Functions to apply cloud mask to different collections
 * 
 * Author: Rodrigo E. Principe
 * email: fitoprincipe82@gmail.com
 * License: MIT
 */

var test_import = function() {
  print('cloud_masks module imported')
}

var help = {};

var computeQAbits = function(start, end, newName) {
  var pattern = ee.Number(0)
  
  start = ee.Number(start).toInt()
  end = ee.Number(end).toInt()
  newName = ee.String(newName)
  
  var seq = ee.List.sequence(start, end)
  
  var patt = seq.iterate(
    function(element, ini) {
      ini = ee.Number(ini)
      var bit = ee.Number(2).pow(ee.Number(element));
      return ini.add(bit)
    }, pattern)
    
  patt = ee.Number(patt).toInt()
  
  var wrap = function(image) {
    var good_pix = image.select([0], [newName]).bitwiseAnd(patt).rightShift(start);
    return good_pix.toInt()
  }
  return wrap
}

var compute = function(image, mask_band, bits, options) {
  // cast params in case they are not EE objects
  var bits_dict = ee.Dictionary(bits)
  var opt = ee.List(options)
  image = ee.Image(image).select(mask_band)
  
  var first = ee.Image.constant(0) // init image
  
  // function for iterate over the options
  var for_iterate = function(option, ini) {
    var i = ee.Image(ini) // cast ini
    
    // bits relation dict contains the option?
    var cond = bits_dict.contains(option);
    
    // get the mask for the option
    var mask = computeQAbits(bits_dict.get(option), bits_dict.get(option), option)(image)
    return ee.Image(ee.Algorithms.If(cond, 
                                     i.or(mask), 
                                     i))
  }
  
  var good_pix = ee.Image(opt.iterate(for_iterate, first))
  
  return good_pix.not();
}

var sentinel2 = function(options) {
  var opt = options || ['opaque', 'cirrus']
  var rel = {opaque: 10, cirrus:11}
  var band = 'QA60'
  
  var wrap = function(img){
    var good_pix = compute(img, band, rel, opt)
    return img.updateMask(good_pix)
  }
  return wrap
}

var landsatSR_ = function(options) {
  var bits = ee.Dictionary({'cloud': 1, 'shadow': 2, 'adjacent': 3, 'snow': 4});
  var opt = options || ['cloud', 'shadow', 'adjacent', 'snow'];
  
  options = ee.List(opt);
  
  var wrap = function(image) {
      var bands = image.bandNames();
      var contains_sr = bands.contains('sr_cloud_qa');
      
      var compute = function(rel) {
        var first = ee.Image.constant(0)
        var good_pix = ee.Image(
          options.iterate(function(o, ini){
            var cond = rel.contains(o);
            
            var i = ee.Image(ini);
            var m = ee.Image(rel.get(o));
            return ee.Image(ee.Algorithms.If(cond, i.or(m), i));
          }, first)
        );
      
        return good_pix.not();
      }
  
      var sr = function() {
          var mask = image.select('sr_cloud_qa');
          var cloud_mask = computeQAbits(1, 1, 'cloud')(mask);
          var shadow_mask = computeQAbits(2, 2, 'shadow')(mask);
          var adjacent_mask = computeQAbits(3, 3, 'adjacent')(mask);
          var snow_mask = computeQAbits(4, 4, 'snow')(mask);
          
          var rel = ee.Dictionary({
            'cloud': cloud_mask, 
            'shadow': shadow_mask,
            'snow': snow_mask,
            'adjacent': adjacent_mask
          })
          
          return compute(rel);
      }
  
      var pix = function() {
          var mask = image.select('pixel_qa')
          var cloud_mask = computeQAbits(5, 5, 'cloud')(mask)
          var shadow_mask = computeQAbits(3, 3, 'shadow')(mask)
          var snow_mask = computeQAbits(4, 4, 'snow')(mask)
          
          var rel = ee.Dictionary({
            'cloud': cloud_mask, 
            'shadow': shadow_mask,
            'snow': snow_mask
          })
          
          return compute(rel);
      }
  
      var good_pix = ee.Algorithms.If(contains_sr, sr(), pix());
  
      return image.updateMask(good_pix);
  }
  return wrap;
}

var landsatSR = function(options) {
  var sr = {bits: ee.Dictionary({'cloud': 1, 'shadow': 2, 'adjacent': 3, 'snow': 4}),
            band: 'sr_cloud_qa'}
  
  var pix = {bits: ee.Dictionary({'cloud': 5, 'shadow': 3, 'snow': 4}),
            band: 'pixel_qa'}
            
  // Parameters
  var opt = options || sr.bits.keys();
  options = ee.List(opt);
  
  var wrap = function(image) {
    var bands = image.bandNames();
    var contains_sr = bands.contains('sr_cloud_qa');
    var good_pix = ee.Image(ee.Algorithms.If(contains_sr, 
                            compute(image, sr.band, sr.bits, opt),
                            compute(image, pix.band, pix.bits, opt)))
    
    // var good_pix = compute(image, mask_band, bits, opt)
    return image.updateMask(good_pix)
  }
  return wrap
}

var landsatTOA = function(options) {
  var bits = ee.Dictionary({'cloud': 4, 'shadow': 8, 'snow': 10});
  var mask_band = 'BQA'
  
  // Parameters
  var opt = options || bits.keys();
  options = ee.List(opt);
  
  var wrap = function(image) {
    var good_pix = compute(image, mask_band, bits, opt)
    return image.updateMask(good_pix);
  }
  return wrap
}
 
var modis = function(options) {
  var bits = ee.Dictionary({
    'cloud': 0, 
    'mix': 1, 
    'shadow': 2, 
    'cloud2':10, 
    'snow':12
  });
  
  var opt = options || bits.keys()
  var mask_band = 'state_1km'
  
  options = ee.List(opt);
  var wrap = function(image) {
    var good_pix = compute(image, mask_band, bits, opt)
    return image.updateMask(good_pix);
  }
  return wrap
}

var make = {
  sentinel2: sentinel2,
  landsatSR: landsatSR,
  landsatTOA: landsatTOA,
  modis: modis
}

help['sentinel2'] = 'function to mask out clouds of Sentinel 2 images. Use on map function directly';
help['landsatSR'] = 'function to mask out clouds of Landsat SR images. There is one argument to specify what to mask'+
                    'if ommited all options will be masked out (cloud, shodow, adjacent and snow)'

exports.test_import = test_import
exports.help = help
exports.sentinel2 = sentinel2
exports.landsatSR = landsatSR
exports.landsatTOA = landsatTOA
exports.make = make