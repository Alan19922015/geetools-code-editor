var lalg = require('users/fitoprincipe/geetools:list_algorithms')

var binary = function(conditions, classes) {
 /*
 Binary decision tree
 
 conditions: an object holding conditions. Example: {1: img.gt(0), 2: img.lt(500)}
 classes: a dict holding paths for different classes. 
          Example: {water:[[1,1], [2,0]], land: [[1,0],[2,1}]}
                   this means that the 'water' class will be when condition 1 is true
                   and condition 2 is false, and 'land' class will be when condition
                   1 is false and cond 2 is true
 
 */
 
 var cond = ee.Dictionary(conditions)
 var paths = ee.Dictionary(classes)
 
 var C = function(condition, bool) {
   //var b = ee.Number(bool)
   return ee.Image(ee.Algorithms.If(bool, ee.Image(condition), ee.Image(condition).not()))
 }
 
 var wrap = function(img) {
   
   // function to iterate over the path (classes)
   var overpath = function(key, path) {
     var v = ee.List(path) // the path is a list of lists
     
     // define an intial image = 1 with one band with the name of the class
     var ini = ee.Image.constant(1).select([0], [key])
     
     // iterate over the path (first arg is a pair: [cond, bool])
     var result = ee.Image(v.iterate(function(pair, init){
       init = ee.Image(init)
       pair = ee.List(pair)
       var boolean = pair.get(1)
       var condition_key = pair.get(0)  // could need var casting
       var condition = cond.get(condition_key)
       var final_condition = C(condition, boolean)
       return ee.Image(init.and(ee.Image(final_condition)))
     }, ini))
     return result
   }
   var new_classes = ee.Dictionary(paths.map(overpath))
   
   // UNIFY CLASSES. example: {'snow-1':x, 'snow-2':y} into {'snow': x.and(y)}
   var new_classes_list = new_classes.keys()
   
   var repeated = new_classes_list.map(function(el){
     return ee.String(el).split('-').get(0)
   })
   
   var unique = lalg.remove_duplicates(repeated)
   
   var ini = ee.Dictionary.fromLists(unique, ee.List.repeat(ee.Image(0), unique.size()))
   var unify = function(key, init) {
     init = ee.Dictionary(init)
     var baseclass = ee.String(key).split('-').get(0)
     var mask_before = ee.Image(init.get(baseclass))
     var mask = new_classes.get(key)
     var new_mask = mask_before.and(mask)
     return init.set(baseclass, new_mask)
   }
   var new_classes_unique = ee.Dictionary(new_classes_list.iterate(unify, ini))
   
   var masks = new_classes_unique.values() // list of masks
   
   // ADD CLASSES AS BANDS OF THE IMAGE
   return ee.Image(masks.iterate(function(mask, ini){
        ini = ee.Image(ini)
        return ini.addBands(mask)
      }, img))
 }
 return wrap
}

exports.binary = binary